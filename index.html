<!DOCTYPE html>
<html>
    <head>
        <title>
            C compiler tutorial
        </title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="icon" type="image/x-icon" href="assets/logo.ico">
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto:wght@300&display=swap">
        <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@100&family=Roboto:wght@300&display=swap">
        <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@100&family=Raleway:wght@300&family=Roboto:wght@300&display=swap">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-light.min.css">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
        <link rel="stylesheet" href="styles.css">
    </head>

    <script async src="https://www.googletagmanager.com/gtag/js?id=G-CBJWK8BNDP"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-CBJWK8BNDP');
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <body>
        <div id="hor-scroll-bar" style="display:block;position:fixed;top:0;left:0;
        background-color:rgb(5, 241, 5);height:1vh;"></div>
        <div id="content-navigation-anim" style="display:none">
            <div id="content-navigation-body">
                <p style="font-family:Inter,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;font-size:3em">
                    Contents
                </p>
                <ul style="font-size:2em;font-weight:normal;list-style:none;line-height:2em;
                font-family:Inter,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif">
                    <li class="make-bold-0" style="font-weight:bold">Introduction</li>
                    <li class="make-bold-1">Lexing</li>
                    <li class="make-bold-2">Parsing</li>
                    <li class="make-bold-3">Evaluation</li>
                </ul>
            </div>
        </div>
        <div id="nav-icon" onclick="toggleContentBar()">
            <div class="bar bar1"></div>
            <div class="bar bar2"></div>
            <div class="bar bar3"></div>
        </div>
        <div id="logo-image" style="width:100%;text-align: center;">
            <img class="logo-image" src="assets/logo.png" alt="rtdev logo">
        </div>
        <div style="height:3rem"></div>
        <h1 id="header-content-0">Writing a C compiler from scratch</h1>
        <h1 id="header-content-1" style="display:none">Writing C compiler - Part 1, Lexing</h1>
        <h1 id="header-content-2" style="display:none">Writing C compiler - Part 2, Parsing</h1>
        <h1 id="header-content-3" style="display:none">Writing C compiler - Part 3, Evaluation</h1>
        <div class="article-block">
            <p><b>Contents</b></p>
            <ul>
                <li class="make-bold-0" id="option-0" style="color:rgb(0, 119, 255);font-weight:bold;" onclick="chooseOption(0)">Introduction</li>
                <li class="make-bold-1" id="option-1" onclick="chooseOption(1)">Lexing</li>
                <li class="make-bold-2" id="option-2" onclick="chooseOption(2)">Parsing</li>
                <li class="make-bold-2" id="option-3" onclick="chooseOption(3)">Evaluation</li>
            </ul>
        </div>
        <div class="wrapper" id="content-0">
            <p>
                Writing a compiler can be challenging and fun. It's fun if you simply take it up as an exercise to learn about lexing,
                parsing and code generation. Not so fun if you try to implement an actual general purpose language in all it's glory.
            </p>
            <p>
                Check out this repo to see how I made a simple C compiler<br>
            <a href="https://github.com/RohitRTdev/simc">https://github.com/RohitRTdev/simc</a>
            </p>
            <p>
                To keep this process enjoyable, we will only be building a C compiler that supports a subset of the language features.
                For more info on the exact features implemented, please visit the repo. With that in mind, let's get onto it.
            </p>
            <p>
                To write any compiler, we need to do 3 main tasks
            </p>
            <ol>
                <li>Lexing</li>
                <li>Parsing</li>
                <li>Evaluation and code-generation</li>
            </ol>
            <p>
                To understand these 3 processes, let's first see what we are even trying to do. Whenever faced with a complex task, take a simple example first and see how the solution looks for that case alone, and then work on generalizing it.
                <br><br>Let's consider the code:
            </p>
<pre class="manual-highlight">
    <span style="color:rebeccapurple;"><b>int </b></span>a = b + c * d++ - *m;
</pre>
            <div class="code-block">
            </div>
            <p>
                How do we generate the code for this above statement. Before even answering this question,
                we need to first ask ourselves what architecture do we want to generate code for.
                I have decided to use the famous x64 / AMD64 architecture since it is the most widely used one in consumer PC's and laptops.
            </p>
            <p>
                Now that we've decided the arch, let's see how the assembly for the code snippet above looks like.
            </p>
<pre class="manual-highlight">
x64 asm att syntax
    <span  style="color: rgb(136, 136, 136);">//d++</span>
    movl -<span  style="color: rgb(136, 0, 0);">12</span>(<span  style="color: rgb(57, 115, 0);">%rbp</span>), <span  style="color: rgb(57, 115, 0);">%ebx</span> <span  style="color: rgb(136, 136, 136);">//Load 'd'(assume it's stored at stack location rbp-12)</span>
    addl <span  style="color: rgb(136, 0, 0);">1</span>, -<span  style="color: rgb(136, 0, 0);">12</span>(<span  style="color: rgb(57, 115, 0);">%rbp</span>) <span  style="color: rgb(136, 136, 136);">//Increment 'd'</span>
    <span  style="color: rgb(136, 136, 136);">//c * d++</span>
    movl -<span  style="color: rgb(136, 0, 0);">8</span>(<span  style="color: rgb(57, 115, 0);">%rbp</span>), <span  style="color: rgb(57, 115, 0);">%eax</span> <span  style="color: rgb(136, 136, 136);">//Load 'c'</span>
    imull <span  style="color: rgb(57, 115, 0);">%ebx</span>, <span  style="color: rgb(57, 115, 0);">%eax</span> <span  style="color: rgb(136, 136, 136);">// Signed multiply c * d++, now res0 = c * d++</span>
    <span  style="color: rgb(136, 136, 136);">//*m</span>
    movq -<span  style="color: rgb(136, 0, 0);">24</span>(<span  style="color: rgb(57, 115, 0);">%rbp</span>), <span  style="color: rgb(57, 115, 0);">%rbx</span> <span  style="color: rgb(136, 136, 136);">//Load 'm'(We're loading into rbx since pointer is 8 bytes)</span>
    movl (<span  style="color: rgb(57, 115, 0);">%rbx</span>), <span  style="color: rgb(57, 115, 0);">%ebx</span> <span  style="color: rgb(136, 136, 136);">//Dereference pointer 'm', so res1 = *m</span>
    <span  style="color: rgb(136, 136, 136);">//sub res1 from res0</span>
    subl <span  style="color: rgb(57, 115, 0);">%eax</span>, <span  style="color: rgb(57, 115, 0);">%ebx</span> <span  style="color: rgb(136, 136, 136);">// Now res2 = res0 - res1</span>
    <span  style="color: rgb(136, 136, 136);">//b + res2</span>
    addl (<span  style="color: rgb(57, 115, 0);">%rbp</span>), <span  style="color: rgb(57, 115, 0);">%ebx</span> <span  style="color: rgb(136, 136, 136);">// This gives us the final result</span>
    <span  style="color: rgb(136, 136, 136);">//a = final_result</span>
    movl <span  style="color: rgb(57, 115, 0);">%ebx</span>, -<span  style="color: rgb(136, 0, 0);">28</span>(<span  style="color: rgb(57, 115, 0);">%rbp</span>) <span  style="color: rgb(136, 136, 136);">//Store final result at 'a'</span>
</pre>
            <p>
                Variables b, c and d are assumed to be of type int and m is assumed to be of type int* .
            </p>
            <p>
                Notice a few things here. First the variable's location. In C, variables are mostly stored in the stack, and it grows downwards in x64 arch. 
                This is not the case always though (variables could also be located in static memory or heap). Also notice the offsets at which the variables are stored. They are allocated in such a way that all the variables are aligned on their natural boundary( int variables are aligned on 4 byte boundaries and pointers are aligned on 8 byte boundaries).
            </p>
        </div>
        <div class="wrapper" id="content-1" style="display:none">
            <p>
                Now that we've generated the code, let's see how to make our compiler do this. To perform this, what should we do first?
            </p>
            <p>
                The compiler will only be given an input file, which contains a huge string.
                We need to make sense of this string, i.e convert it into symbols that the C language understands.
                This is where step 1 comes in, Lexing. In this step, we break the input set of characters into tokens that our compiler understands.
            </p>
            <p>
                After lexing, we should generate a list of tokens from our input string
            </p>
<pre class="manual-highlight">
    <span class="token-highlight">token1:</span> Type:<span class="type-highlight">keyword</span>, symbol:<span class="symbol-highlight">int</span>
    <span class="token-highlight">token2:</span> Type:<span class="type-highlight">Identifier</span>, symbol:<span class="symbol-highlight">'a'</span>
    <span class="token-highlight">token3:</span> Type:<span class="type-highlight">Operator</span>, symbol:<span class="symbol-highlight">'='</span>
    <span class="token-highlight">token4:</span> Type:<span class="type-highlight">Identifier</span>, symbol:<span class="symbol-highlight">'b'</span>
    <span class="token-highlight">token5:</span> Type:<span class="type-highlight">Operator</span>, symbol:<span class="symbol-highlight">'+'</span>
    <span class="token-highlight">token6:</span> Type:<span class="type-highlight">Identifier</span>, symbol:<span class="symbol-highlight">'c'</span>
    <span class="token-highlight">token7:</span> Type:<span class="type-highlight">Operator</span>, symbol:<span class="symbol-highlight">'*'</span>
    <span class="token-highlight">token8:</span> Type:<span class="type-highlight">Identifier</span>, symbol:<span class="symbol-highlight">'d'</span>
    <span class="token-highlight">token9:</span> Type:<span class="type-highlight">Operator</span>, symbol:<span class="symbol-highlight">'++'</span>
    <span class="token-highlight">token10:</span> Type:<span class="type-highlight">Operator</span>, symbol:<span class="symbol-highlight">'-'</span>
    <span class="token-highlight">token11:</span> Type:<span class="type-highlight">Operator</span>, symbol:<span class="symbol-highlight">'*</span>
    <span class="token-highlight">token12:</span> Type:<span class="type-highlight">Identifier</span>, symbol:<span class="symbol-highlight">'m'</span>
</pre>
        <p>
            All of the lexer code is included in the lexer.cpp file under src/simcc. 
            It simply iterates through the list of characters and tries to generate a <b>token object</b>. 
            This object is defined in token.h header file under include/compiler folder.
        </p>

        <p>
            The logic to generate this is implemented using a simple lookahead parser. This means that
            we need to atmost look one extra token to the right, before we can decide what the token is.
            The lexer and the parser are implemented as state machines. Each state tells the lexer how to process
            the current token and about how to reduce it (That is figure out what this token is).
        </p>

<pre><code class="language-cpp"><span class="language-tag">C++</span>
    if(state == LEXER_START) {
        sim_log_debug("In state LEXER_START. Searching for operator token.");
        switch(ch) {
            case ';': op = SEMICOLON; break;
            case '{': op = CLB; break;
            case '}': op = CRB; break;
            case '~': op = BIT_NOT; break;
            case '*': op = MUL; break;
            case '/': op = DIV; break;
            case '%': op = MODULO; break;
            case '^': op = BIT_XOR; break;
            case '(': op = LB; break;
            case ')': op = RB; break;
            case '[': op = LSB; break;
            case ']': op = RSB; break;
            case ',': op = COMMA; break;
            case '!': {
                state = EXTENDED_OPERATOR_TOKEN;
                prev_op = NOT;
                break;
            } 
            case '+': {
                state = EXTENDED_OPERATOR_TOKEN;
                prev_op = PLUS;
                break;
            }
            case '-': {
                state = EXTENDED_OPERATOR_TOKEN;
                prev_op = MINUS;
                break;
            }
            case '&': {
                state = EXTENDED_OPERATOR_TOKEN;
                prev_op = AMPER;
                break;
            }
            case '|': {
                state = EXTENDED_OPERATOR_TOKEN;
                prev_op = BIT_OR;
                break;
            }
            case '<': {
                state = EXTENDED_OPERATOR_TOKEN;
                prev_op = LT;
                break;
            }
            case '>': {
                state = EXTENDED_OPERATOR_TOKEN;
                prev_op = GT;
                break;
            }
            case '=': {
                state = EXTENDED_OPERATOR_TOKEN;
                prev_op = EQUAL;
                break;
            }
            default: {
                state = LOOKAHEAD_FOR_CONSTANT;
            }
        }
    }
</code></pre>
        <p>
            The lexer starts at state <b>LEXER_START</b>. It checks if the given character(<I>ch</I>) 
            is an operator. Most of the operators can be determined using just one character such as <b>'*'</b>
            or <b>'~'</b>. However, certain operators need further processing. This is why for certain other operators 
            we go to <b>EXTENDED_OPERATOR_TOKEN</b> state. This state terminates and goes back to <b>LEXER_START</b> 
            once it has determined the operator it is looking for by fetching the next character.
        </p>
        <p>
            An example of such a character is <b>'++'</b>. When lexer fetches the first plus, it cannot immediately reduce that token, and can only do so 
            once it has determined the next character (If the next character is a '+', then it gets interpreted as '++' otherwise just a single '+').
        </p>

        <p>Once a particular token is determined, a <b>token</b> object is generated. The token object is declared as follows.</p>
<pre><code class="language-cpp"><span class="language-tag">C++</span>
    struct token {
        private:
            token_type type;
            token_sub_type sub_type;
            size_t position;
            bool is_keyword_data_type() const;

        public:
            std::variant<char, std::string, operator_type, keyword_type> value;

            template<typename T>
            token(token_type _type, const T& val) : type(_type) {
                value = val;
                position = global_token_pos - 1;
            }
        
            token(token_type _type, token_sub_type _sub_type, const std::string& num) {
                type = CONSTANT;
                sub_type = _sub_type;
                value = num;
                position = global_token_pos - 1;
            }
        
            token(token_type _type, const char& val) {
                type = CONSTANT;
                sub_type = TOK_CHAR;
                value = val;
                position = global_token_pos - 1;
            }
    }
</code></pre>
        <p>
            This token class has been simplified and not all fields displayed in this are integral 
            to the conceptual understanding of the lexer. It is pretty self explanatory and stores information on
            what type of token it is (KEYWORD, OPERATOR, LITERAL etc) along with the value of that token. For example, 
            if it is a string literal, then what is that literal.
        </p>
        <p>
            Once all characters within the file are processed, the final token stream is passed on to the 
            parser stage.
        </p>
        </div>
        <div class="wrapper" id="content-2" style="display:none">
            <p>
            Parsing involves taking the input stream we had earlier and producing an <b>abstract syntax tree</b>(ast).
            The ast is a simple tree structure that tells the compiler in what order we must perform the operations listed.
            </p>
            <p>
                Below picture shows the ast of the previous expression that our compiler generates.
            </p>
            <div class="img-class">
                <img src="assets/ast.png" alt="AST of the previous C expression">
            </div>
            <p>
               A <I>declaration list</I> contains multiple comma separated declarations. A declaration contains a 
               <I>declarator</I>. A declarator could contain an identifier (it's optional since abstract declarators doesn't contain identifier). 
               Declarator's could also contain modifiers (such as pointer or array declarator). Our case is a very simple declarator that contains 
               only an identifier (In C parlance, this is called an unmodified type).  
            </p>
            <p>
                The definition that I gave above could also be condensed into a notation as follows.
            </p>
<pre class="manual-highlight">
Taken from msdn website    
    <b>declarator:</b>
        pointeropt direct-declarator

    <b>direct-declarator:</b>
        identifier
        ( declarator )
        direct-declarator [ constant-expressionopt ]
        direct-declarator ( parameter-type-list )
        direct-declarator ( identifier-listopt )

    <b>pointer:</b>
        * type-qualifier-listopt
        * type-qualifier-listopt pointer

    <b>type-qualifier-list:</b>
        type-qualifier
        type-qualifier-list type-qualifier
</pre>
        <p>
            The above definition is what is known as grammar. Although this is only showing the grammar (structure) 
            of how declarations in C are laid out. Using this notation, we can describe all kinds of constructs within 
            that language. It consists of two tokens, <b>terminal</b> and <b>non-terminal</b>. Terminal tokens are those 
            which cannot be split further into simpler tokens. For example, <b>type-qualifier</b> (static, extern, auto, register) is a terminal token whereas 
            <b>declarator</b> is a non terminal token.
        </p>
        <h2>Parser design</h2>
        <p>
            You don't have to write a parser from scratch necessarily. There are tools such as <I>bison</I>, which will 
            generate files written in C that implements a state machine which will parse your grammar. You simply need 
            to give it the rules for your grammar, and it will generate the files for you.
        </p>
        <p>
            However, simc uses it's own parser written from scratch. It is simply a state machine. State machines are 
            abstract structures that allow us to visualize the flow of the <I>state</I> of a machine given a set of inputs.
            Each state is described by what kind of input it takes, and which state it proceeds to after getting that input.
            Let us take a look at a state machine for parsing a C expression. For the sake of this tutorial, we'll proceed a simplified 
            form of the C expression. The grammar for it is as follows.
        </p>
<pre class="manual-highlight">
<span style="color:darkblue;font-weight: bold;">Simplified expression grammar for C</span>
    <b>&ltexpr&gt</b> ::= <b>&ltexpr&gt</b> binary_operator <b>&ltexpr&gt</b>
    <b>&ltexpr&gt</b> ::= <b>&ltexpr&gt</b> postfix_operator
    <b>&ltexpr&gt</b> ::= unary_operator <b>&ltexpr&gt</b>
    <b>&ltexpr&gt</b> ::= identifier 
    <b>&ltexpr&gt</b> ::= constant 
</pre>
        <p>
            Let's try parsing expressions with the above grammar. Our parser uses states which has only 2 pathways.
            Yes/No. Each state has a <b>yes</b> token. If the state machine finds that the current token is equal to the 
            <b>yes</b> token, then we proceed to a given state, otherwise we proceed to the next state. <I>The point to be noted 
            here is that, we could have designed a state machine where a given state could have proceeded into more that 2 states 
            but we chose to restrict it to just 2 states</I>. The reason for this design will be clear in a second. 
        </p>
        
        <p>
            Let's take a look at a simple state machine that parses this table
        </p>
        <div class="img-class">
            <img src="assets/state-machine.png" alt="State machine for parsing simple C expression">
        </div>
        <p>
            We start out by fetching tokens one by one from our token stream. Our start state in this case will be set to <em>EXPECT_UNARY_OP</em>.  
            For each token, our parser checks if the token happens to be what the state mentions. If it is that token, then we go to the <b>yes</b> state. 
            If it's any other token we proceed to the <b>no</b> state. This means that if the first token is a unary operator, then we proceed to state 
            <em>EXPECT_UNARY_OP</em>, otherwise we proceed to state <em>EXPECT_IDENT</em>.
        </p>
        <p>
            Within our parser, we define states like so
        </p>
<pre><code class="language-cpp"><span class="language-tag">C++</span>
static void parse_expr() {

    //At start of expression
    parser.define_shift_state("EXPECT_EXPR_UOP", EXPECT_EXPR_UOP, &token::is_unary_operator, EXPECT_EXPR_VAR, create_ast_unary_op);
    parser.define_shift_state("EXPECT_EXPR_VAR", EXPECT_EXPR_POP, &token::is_identifier, EXPECT_EXPR_CON, create_ast_expr_var);
    parser.define_shift_state("EXPECT_EXPR_CON", EXPECT_EXPR_POP, &token::is_constant, EXPECT_EXPR_LB, create_ast_expr_con);
    parser.define_shift_state("EXPECT_EXPR_LB", EXPECT_EXPR_UOP_S, &token::is_operator_lb, EXPECT_EXPR_RB, create_ast_punctuator, nullptr, LB_EXPR_REDUCE);
    
    //After an expression
    parser.define_state("EXPECT_EXPR_POP", EXPECT_EXPR_POP, &token::is_postfix_operator, EXPECT_EXPR_BOP, false, reduce_expr_postfix);
    parser.define_state("EXPECT_EXPR_BOP", EXPECT_EXPR_UOP_S, &token::is_binary_operator, EXPECT_EXPR_FN_LB, false, reduce_expr_bop);
    parser.define_shift_state("EXPECT_EXPR_FN_LB", EXPECT_EXPR_UOP_S, &token::is_operator_lb, EXPECT_EXPR_LSB, create_ast_punctuator, nullptr, FN_CALL_EXPR_REDUCE);
    parser.define_shift_state("EXPECT_EXPR_LSB", EXPECT_EXPR_UOP_S, &token::is_operator_lsb, EXPECT_EXPR_RB, create_ast_punctuator, nullptr, ARRAY_SUBSCRIPT_REDUCE);

    //Terminal components in an expression
    parser.define_special_state("EXPECT_EXPR_RB", &token::is_operator_rb, reduce_expr_rb, EXPECT_EXPR_RSB); 
    parser.define_special_state("EXPECT_EXPR_RSB", &token::is_operator_rsb, reduce_expr_rsb, EXPECT_EXPR_SC);
    parser.define_special_state("EXPECT_EXPR_SC", &token::is_operator_sc, reduce_expr_stmt, PARSER_ERROR,  
    "Expected expression to terminate with ')' or ',' or ';'");

    //States that start an expression but appear after an existing expression
    parser.define_shift_state("EXPECT_EXPR_UOP_S", EXPECT_EXPR_UOP_S, &token::is_unary_operator, EXPECT_EXPR_VAR_S, create_ast_unary_op);
    parser.define_shift_state("EXPECT_EXPR_VAR_S", EXPECT_EXPR_POP, &token::is_identifier, EXPECT_EXPR_CON_S, create_ast_expr_var);
    parser.define_shift_state("EXPECT_EXPR_CON_S", EXPECT_EXPR_POP, &token::is_constant, EXPECT_EXPR_LB_S, create_ast_expr_con);
    parser.define_shift_state("EXPECT_EXPR_LB_S", EXPECT_EXPR_UOP_S, &token::is_operator_lb, EXPECT_EXPR_FN_RB_S, create_ast_punctuator, nullptr, LB_EXPR_REDUCE);
    parser.define_state("EXPECT_EXPR_FN_RB_S", EXPECT_EXPR_POP, &token::is_operator_rb, PARSER_ERROR, false, reduce_expr_empty_fn, 
    "Expected unary op, var, constant, '(' for start of expression");
}
</code></pre>
        <p>
            The define_*_state functions will internally create a state object and will include it to the state machine. When the state machine is started it goes through 
            each of these states. The code shown above implements the state machine for a complete C expression, so you may see states that we didn't show in the picture. 
            Now let's discuss about how the parser actually generates the ast. 
        </p>
        <p>
            The state machine includes a stack object which we call the <em>parser stack</em>. When we hit the <b>yes</b> condition in a state, it does one of three things. 
            <ul>
                <li>Shift -> Push the token into stack</li>
                <li>Reduce -> Call a reduce function, which will combine the tokens in the stack</li>
                <li>Pass -> This will do neither of the above, and simply proceed to the next state</li>
            </ul>
            This is why we have many different types of define_functions declared in our code. Each one will tell how our state must react to a <b>yes</b> condition. 
            The <em>reduce</em> function is different for different states. If the state hits the <b>no</b> condition, then it simply proceeds to the <b>no</b> state. 
        </p>
        <p>
            When we walk through the states, we follow these additional rules. <br>
            <I>Note: This is only valid for expression parsing.</I>
            <ul>
                <li>If we hit <b>yes</b> condition for <em>EXPECT_BINARY_OP</em>, we invoke binary_op_reduction</li>
                <li>If we hit <b>yes</b> condition for <em>EXPECT_POSTFIX_OP</em>, we invoke postfix_op_reduction</li>
                <li>If we hit <em>REDUCE_EXPRESSION</em> state, we invoke expr_reduction</li>
            </ul>
            For each of these reductions, we fetch a token from the top of the <em>parser stack</em> and perform an operation depending on the reduction type and 
            the type of the token we're dealing with. From here on we'll refer to the token we fetched from the token stream as <b>cur_token</b> and the token we fetched 
            from the <em>parser stack</em> as <b>parser_token</b>.
<pre class="manual-highlight">
    <b>binary_op_reduction:</b>
        Rule 1) If <b>parser_token</b> is not an operator, we don't do anything and simply fetch the next <b>parser_token</b>.
        Rule 2) If <b>parser_token</b> is an operator, and it has lower priority than <b>cur_token</b>, then we stop our reduction, shift the <b>cur_token</b> and continue with the next state.
        Rule 3) If <b>parser_token</b> is an operator, and it has higher priority than <b>cur_token</b>, then we invoke the combination rule for that operator according to rule 7-8, and then continue with the next <b>parser_token</b>.
        Rule 4) If <b>parser_token</b> is an operator, and it has the same priority as <b>cur_token</b>, then we invoke rule 5 or rule 6.
        Rule 5) If <b>parser_token</b> has LHS associativity, we combine the operator according to rule 7-8, and then continue with the next <b>parser_token</b>.
        Rule 6) If <b>parser_token</b> has RHS associativity, then we stop our reduction, shift the <b>cur_token</b> and continue with the next state.
        Rule 7) If we find a binary operator, then we create an ast node with the root of the node being the operator and left and right nodes of it being the nodes below and above it in the <em>parser stack</em> respectively. Push the newly created ast onto the stack.
        Rule 8) If we find a unary operator, then we create an ast node with the root of the node being the operator and it's child node being the node above it in the <em>parser stack</em>. Push the newly created ast onto the stack.
        Rule 9) If we hit the end of the stack, we stop reduction, shift the <b>cur_token</b> and continue with the next state.
    
    <b>postfix_op_reduction:</b>
        Create an ast node with the root being the postfix operator, and it's child being the top node on the <em>parser stack</em>.
        Then push the ast onto the <em>parser stack</em>.

    <b>expr_reduction:</b>
        For each <b>parser_token</b> in <em>parser stack</em>:
            if <b>parser_token</b> is binary_operator:
                Reduce according to rule 7
            if <b>parser_token</b> is unary_operator:
                Reduce according to rule 8
</pre>
        <p>
            When done with <em>expr_reduction</em>, we should only be left with one node in the <em>parser stack</em>. This node should represent the ast for our expression. All 
            the code for the parser can be found under parser.cpp and the state-machine logic is implemented in state-machine.cpp.
        </p>
        </p>
        </div>
        <div class="wrapper" id="content-3" style="display:none">
            Content to soon show up...
        </div>
        <div class="navigator">
            <hr style="border-color:grey">
            <div class="add-span-margin">
                <span onclick="choosePrevOption()" id="prev-tab" style="display:none">Prev</span>
                <span onclick="chooseNextOption()" id="next-tab">Next</span>
            </div>
        </div>
        <div class="contact-info"; style="display:flex;flex-direction:column;background-color:grey;color:lightgray;
            width:100%;min-height:10rem;text-align:center; justify-content: center;align-items:center;
            font-family:Raleway,'Trebuchet MS', 'Lucida Sans Unicode', 'Lucida Grande', 'Lucida Sans', Arial, sans-serif;
            flex-wrap:wrap;flex-grow:1">
            <p style="margin-bottom:0;flex-grow:1;font-weight:bold;font-size:1.8em;">
                Rohit Jacob George
            </p>
            <p style="flex-grow:1;font-size:1.1em">In case of queries or mistakes you may find, please reach out 
            to me via my email - <u>rohit20011002@gmail.com</u></p>
            <div class="row-break"></div>
            <div class="icons">
                <a target="_blank" href="https://www.linkedin.com/in/rohit-jacob-george-3190361b3" class="social-media-icon">
                    <i class="fa fa-linkedin"></i>
                </a>
                <a target="_blank" href="https://github.com/RohitRTdev" class="social-media-icon">
                    <i class="fa fa-github"></i>
                </a>
            </div>
            <p style="font-size:0.9em">
                &#169 2023 Rohit Jacob George. All Rights Reserved.
            </p>
        </div>
    <script>
        if (!("ontouchstart" in document.documentElement)) {
            document.documentElement.classList.add("no-touch");
        }

        hljs.highlightAll();
        document.querySelector(".language-tag").style.color = "black";
        var existingOption = 0;

        let scroll = document.getElementById("hor-scroll-bar");
        let body = document.querySelector("body");
        let contact = document.querySelector(".contact-info");
        body.onscroll = (event) => {
            scroll.style.width = 100 * (window.scrollY / (body.scrollHeight - window.innerHeight)) + "%";
        };

        window.onresize = calcContactPositioning;

        function calcContactPositioning() {
            let netHeight = body.offsetHeight;
            let totalHeight = window.innerHeight;

            if(totalHeight >= netHeight) {
                contact.style.position = "absolute";
                contact.style.bottom = "0";
                contact.style.left = "0"; 
            }
            else {
                contact.style.position = "static";
            }
        }

        calcContactPositioning();
        
        function setNavTab() {
            let prevTab = document.getElementById("prev-tab");
            let nextTab = document.getElementById("next-tab");

            if(existingOption == 0) {
                prevTab.style.display = "none";
            }
            else {
                prevTab.style.display = "";
            }

            if(existingOption == 3) {
                nextTab.style.display = "none";
            }
            else {
                nextTab.style.display = "";
            }
        }

        //chooseOption(2);
        function chooseOption(option) {
            if(option == existingOption)
                return;

            //Change the option highlight
            let make_bold = document.querySelector(".make-bold-"+existingOption);
            let opt = document.getElementById("option-"+existingOption);
            make_bold.style.fontWeight = "normal";
            opt.style.fontWeight = "normal";
            opt.style.color = "";

            let make_bold_new = document.querySelector(".make-bold-"+option);
            let newOpt = document.getElementById("option-"+option);
            make_bold_new.style.fontWeight = "bold";
            newOpt.style.fontWeight = "bold";
            newOpt.style.color = "rgb(0, 119, 255)";


            //Change the content
            opt = document.getElementById("content-"+existingOption);
            opt.style.display = "none";
            newOpt = document.getElementById("content-"+option);
            newOpt.style.display = "";
            opt = document.getElementById("header-content-"+existingOption);
            opt.style.display = "none";
            newOpt = document.getElementById("header-content-"+option);
            newOpt.style.display = "";

            existingOption = option;
            window.scroll(0,0);
            setNavTab();
            calcContactPositioning();
        }

        function chooseNextOption() {
            var option = existingOption + 1;
            chooseOption(option);
        }

        function choosePrevOption() {
            var option = existingOption - 1;
            chooseOption(option);
        }


        var isContentDisplayed = false;

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        async function toggleContentBar() {
            //Display the contents bar
            let anim = document.getElementById("content-navigation-anim");
            if(isContentDisplayed) {
                anim.style.opacity = "0";
                await sleep(100);
                anim.style.display = "none";
                body.style.overflow = "auto";
            }
            else {
                window.scroll(0,0);
                anim.style.display = "block";
                await sleep(100);
                anim.style.opacity = "0.8";
                body.style.overflow = "hidden";
            }

            //Transform the menu icon
            let menuIcon = document.getElementById("nav-icon");
            menuIcon.classList.toggle("animate-bar");

            //Shift the menu icon
            let img = document.getElementById("logo-image");

            if(isContentDisplayed) {
                //Hide img first
                menuIcon.style.right = "95%";
                img.style.visibility = "visible";
                await sleep(500);
                menuIcon.style.left = "0";
                menuIcon.style.display = "";
            }
            else {
                menuIcon.style.right = "0";
                menuIcon.style.left = "unset";
                img.style.visibility = "hidden";
                menuIcon.style.display = "block";
            }

            isContentDisplayed = !isContentDisplayed;

        }
    </script>
    </body>
</html>